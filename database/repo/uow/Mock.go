// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package uow

import (
	"sync"
	"yellowroad_library/database/repo/book_repo"
	"yellowroad_library/database/repo/chapter_repo"
	"yellowroad_library/database/repo/chapterpath_repo"
	"yellowroad_library/database/repo/user_repo"
	"yellowroad_library/utils/app_error"
)

var (
	lockUnitOfWorkMockAuto            sync.RWMutex
	lockUnitOfWorkMockBookRepo        sync.RWMutex
	lockUnitOfWorkMockChapterPathRepo sync.RWMutex
	lockUnitOfWorkMockChapterRepo     sync.RWMutex
	lockUnitOfWorkMockCommit          sync.RWMutex
	lockUnitOfWorkMockRollback        sync.RWMutex
	lockUnitOfWorkMockUserRepo        sync.RWMutex
)

// UnitOfWorkMock is a mock implementation of UnitOfWork.
//
//     func TestSomethingThatUsesUnitOfWork(t *testing.T) {
//
//         // make and configure a mocked UnitOfWork
//         mockedUnitOfWork := &UnitOfWorkMock{
//             AutoFunc: func(in1 []WorkFragment, in2 func() app_error.AppError) app_error.AppError {
// 	               panic("TODO: mock out the Auto method")
//             },
//             BookRepoFunc: func() book_repo.BookRepository {
// 	               panic("TODO: mock out the BookRepo method")
//             },
//             ChapterPathRepoFunc: func() chapterpath_repo.ChapterPathRepository {
// 	               panic("TODO: mock out the ChapterPathRepo method")
//             },
//             ChapterRepoFunc: func() chapter_repo.ChapterRepository {
// 	               panic("TODO: mock out the ChapterRepo method")
//             },
//             CommitFunc: func() app_error.AppError {
// 	               panic("TODO: mock out the Commit method")
//             },
//             RollbackFunc: func() app_error.AppError {
// 	               panic("TODO: mock out the Rollback method")
//             },
//             UserRepoFunc: func() user_repo.UserRepository {
// 	               panic("TODO: mock out the UserRepo method")
//             },
//         }
//
//         // TODO: use mockedUnitOfWork in code that requires UnitOfWork
//         //       and then make assertions.
//
//     }
type UnitOfWorkMock struct {
	// AutoFunc mocks the Auto method.
	AutoFunc func(in1 []WorkFragment, in2 func() app_error.AppError) app_error.AppError

	// BookRepoFunc mocks the BookRepo method.
	BookRepoFunc func() book_repo.BookRepository

	// ChapterPathRepoFunc mocks the ChapterPathRepo method.
	ChapterPathRepoFunc func() chapterpath_repo.ChapterPathRepository

	// ChapterRepoFunc mocks the ChapterRepo method.
	ChapterRepoFunc func() chapter_repo.ChapterRepository

	// CommitFunc mocks the Commit method.
	CommitFunc func() app_error.AppError

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func() app_error.AppError

	// UserRepoFunc mocks the UserRepo method.
	UserRepoFunc func() user_repo.UserRepository

	// calls tracks calls to the methods.
	calls struct {
		// Auto holds details about calls to the Auto method.
		Auto []struct {
			// In1 is the in1 argument value.
			In1 []WorkFragment
			// In2 is the in2 argument value.
			In2 func() app_error.AppError
		}
		// BookRepo holds details about calls to the BookRepo method.
		BookRepo []struct {
		}
		// ChapterPathRepo holds details about calls to the ChapterPathRepo method.
		ChapterPathRepo []struct {
		}
		// ChapterRepo holds details about calls to the ChapterRepo method.
		ChapterRepo []struct {
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
		}
		// UserRepo holds details about calls to the UserRepo method.
		UserRepo []struct {
		}
	}
}

// Auto calls AutoFunc.
func (mock *UnitOfWorkMock) Auto(in1 []WorkFragment, in2 func() app_error.AppError) app_error.AppError {
	if mock.AutoFunc == nil {
		panic("moq: UnitOfWorkMock.AutoFunc is nil but UnitOfWork.Auto was just called")
	}
	callInfo := struct {
		In1 []WorkFragment
		In2 func() app_error.AppError
	}{
		In1: in1,
		In2: in2,
	}
	lockUnitOfWorkMockAuto.Lock()
	mock.calls.Auto = append(mock.calls.Auto, callInfo)
	lockUnitOfWorkMockAuto.Unlock()
	return mock.AutoFunc(in1, in2)
}

// AutoCalls gets all the calls that were made to Auto.
// Check the length with:
//     len(mockedUnitOfWork.AutoCalls())
func (mock *UnitOfWorkMock) AutoCalls() []struct {
	In1 []WorkFragment
	In2 func() app_error.AppError
} {
	var calls []struct {
		In1 []WorkFragment
		In2 func() app_error.AppError
	}
	lockUnitOfWorkMockAuto.RLock()
	calls = mock.calls.Auto
	lockUnitOfWorkMockAuto.RUnlock()
	return calls
}

// BookRepo calls BookRepoFunc.
func (mock *UnitOfWorkMock) BookRepo() book_repo.BookRepository {
	if mock.BookRepoFunc == nil {
		panic("moq: UnitOfWorkMock.BookRepoFunc is nil but UnitOfWork.BookRepo was just called")
	}
	callInfo := struct {
	}{}
	lockUnitOfWorkMockBookRepo.Lock()
	mock.calls.BookRepo = append(mock.calls.BookRepo, callInfo)
	lockUnitOfWorkMockBookRepo.Unlock()
	return mock.BookRepoFunc()
}

// BookRepoCalls gets all the calls that were made to BookRepo.
// Check the length with:
//     len(mockedUnitOfWork.BookRepoCalls())
func (mock *UnitOfWorkMock) BookRepoCalls() []struct {
} {
	var calls []struct {
	}
	lockUnitOfWorkMockBookRepo.RLock()
	calls = mock.calls.BookRepo
	lockUnitOfWorkMockBookRepo.RUnlock()
	return calls
}

// ChapterPathRepo calls ChapterPathRepoFunc.
func (mock *UnitOfWorkMock) ChapterPathRepo() chapterpath_repo.ChapterPathRepository {
	if mock.ChapterPathRepoFunc == nil {
		panic("moq: UnitOfWorkMock.ChapterPathRepoFunc is nil but UnitOfWork.ChapterPathRepo was just called")
	}
	callInfo := struct {
	}{}
	lockUnitOfWorkMockChapterPathRepo.Lock()
	mock.calls.ChapterPathRepo = append(mock.calls.ChapterPathRepo, callInfo)
	lockUnitOfWorkMockChapterPathRepo.Unlock()
	return mock.ChapterPathRepoFunc()
}

// ChapterPathRepoCalls gets all the calls that were made to ChapterPathRepo.
// Check the length with:
//     len(mockedUnitOfWork.ChapterPathRepoCalls())
func (mock *UnitOfWorkMock) ChapterPathRepoCalls() []struct {
} {
	var calls []struct {
	}
	lockUnitOfWorkMockChapterPathRepo.RLock()
	calls = mock.calls.ChapterPathRepo
	lockUnitOfWorkMockChapterPathRepo.RUnlock()
	return calls
}

// ChapterRepo calls ChapterRepoFunc.
func (mock *UnitOfWorkMock) ChapterRepo() chapter_repo.ChapterRepository {
	if mock.ChapterRepoFunc == nil {
		panic("moq: UnitOfWorkMock.ChapterRepoFunc is nil but UnitOfWork.ChapterRepo was just called")
	}
	callInfo := struct {
	}{}
	lockUnitOfWorkMockChapterRepo.Lock()
	mock.calls.ChapterRepo = append(mock.calls.ChapterRepo, callInfo)
	lockUnitOfWorkMockChapterRepo.Unlock()
	return mock.ChapterRepoFunc()
}

// ChapterRepoCalls gets all the calls that were made to ChapterRepo.
// Check the length with:
//     len(mockedUnitOfWork.ChapterRepoCalls())
func (mock *UnitOfWorkMock) ChapterRepoCalls() []struct {
} {
	var calls []struct {
	}
	lockUnitOfWorkMockChapterRepo.RLock()
	calls = mock.calls.ChapterRepo
	lockUnitOfWorkMockChapterRepo.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *UnitOfWorkMock) Commit() app_error.AppError {
	if mock.CommitFunc == nil {
		panic("moq: UnitOfWorkMock.CommitFunc is nil but UnitOfWork.Commit was just called")
	}
	callInfo := struct {
	}{}
	lockUnitOfWorkMockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	lockUnitOfWorkMockCommit.Unlock()
	return mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//     len(mockedUnitOfWork.CommitCalls())
func (mock *UnitOfWorkMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	lockUnitOfWorkMockCommit.RLock()
	calls = mock.calls.Commit
	lockUnitOfWorkMockCommit.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *UnitOfWorkMock) Rollback() app_error.AppError {
	if mock.RollbackFunc == nil {
		panic("moq: UnitOfWorkMock.RollbackFunc is nil but UnitOfWork.Rollback was just called")
	}
	callInfo := struct {
	}{}
	lockUnitOfWorkMockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	lockUnitOfWorkMockRollback.Unlock()
	return mock.RollbackFunc()
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//     len(mockedUnitOfWork.RollbackCalls())
func (mock *UnitOfWorkMock) RollbackCalls() []struct {
} {
	var calls []struct {
	}
	lockUnitOfWorkMockRollback.RLock()
	calls = mock.calls.Rollback
	lockUnitOfWorkMockRollback.RUnlock()
	return calls
}

// UserRepo calls UserRepoFunc.
func (mock *UnitOfWorkMock) UserRepo() user_repo.UserRepository {
	if mock.UserRepoFunc == nil {
		panic("moq: UnitOfWorkMock.UserRepoFunc is nil but UnitOfWork.UserRepo was just called")
	}
	callInfo := struct {
	}{}
	lockUnitOfWorkMockUserRepo.Lock()
	mock.calls.UserRepo = append(mock.calls.UserRepo, callInfo)
	lockUnitOfWorkMockUserRepo.Unlock()
	return mock.UserRepoFunc()
}

// UserRepoCalls gets all the calls that were made to UserRepo.
// Check the length with:
//     len(mockedUnitOfWork.UserRepoCalls())
func (mock *UnitOfWorkMock) UserRepoCalls() []struct {
} {
	var calls []struct {
	}
	lockUnitOfWorkMockUserRepo.RLock()
	calls = mock.calls.UserRepo
	lockUnitOfWorkMockUserRepo.RUnlock()
	return calls
}
