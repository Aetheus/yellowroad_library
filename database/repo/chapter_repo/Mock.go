// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package chapter_repo

import (
	"sync"
	"yellowroad_library/database/entities"
	"yellowroad_library/utils/app_error"
)

var (
	lockChapterRepositoryMockDelete         sync.RWMutex
	lockChapterRepositoryMockFindById       sync.RWMutex
	lockChapterRepositoryMockFindWithinBook sync.RWMutex
	lockChapterRepositoryMockInsert         sync.RWMutex
	lockChapterRepositoryMockUpdate         sync.RWMutex
)

// ChapterRepositoryMock is a mock implementation of ChapterRepository.
//
//     func TestSomethingThatUsesChapterRepository(t *testing.T) {
//
//         // make and configure a mocked ChapterRepository
//         mockedChapterRepository := &ChapterRepositoryMock{
//             DeleteFunc: func(in1 *entities.Chapter) app_error.AppError {
// 	               panic("TODO: mock out the Delete method")
//             },
//             FindByIdFunc: func(in1 int) (entities.Chapter, app_error.AppError) {
// 	               panic("TODO: mock out the FindById method")
//             },
//             FindWithinBookFunc: func(chapter_id int, book_id int) (entities.Chapter, app_error.AppError) {
// 	               panic("TODO: mock out the FindWithinBook method")
//             },
//             InsertFunc: func(in1 *entities.Chapter) app_error.AppError {
// 	               panic("TODO: mock out the Insert method")
//             },
//             UpdateFunc: func(in1 *entities.Chapter) app_error.AppError {
// 	               panic("TODO: mock out the Update method")
//             },
//         }
//
//         // TODO: use mockedChapterRepository in code that requires ChapterRepository
//         //       and then make assertions.
//
//     }
type ChapterRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(in1 *entities.Chapter) app_error.AppError

	// FindByIdFunc mocks the FindById method.
	FindByIdFunc func(in1 int) (entities.Chapter, app_error.AppError)

	// FindWithinBookFunc mocks the FindWithinBook method.
	FindWithinBookFunc func(chapter_id int, book_id int) (entities.Chapter, app_error.AppError)

	// InsertFunc mocks the Insert method.
	InsertFunc func(in1 *entities.Chapter) app_error.AppError

	// UpdateFunc mocks the Update method.
	UpdateFunc func(in1 *entities.Chapter) app_error.AppError

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// In1 is the in1 argument value.
			In1 *entities.Chapter
		}
		// FindById holds details about calls to the FindById method.
		FindById []struct {
			// In1 is the in1 argument value.
			In1 int
		}
		// FindWithinBook holds details about calls to the FindWithinBook method.
		FindWithinBook []struct {
			// Chapter_id is the chapter_id argument value.
			Chapter_id int
			// Book_id is the book_id argument value.
			Book_id int
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// In1 is the in1 argument value.
			In1 *entities.Chapter
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// In1 is the in1 argument value.
			In1 *entities.Chapter
		}
	}
}

// Delete calls DeleteFunc.
func (mock *ChapterRepositoryMock) Delete(in1 *entities.Chapter) app_error.AppError {
	if mock.DeleteFunc == nil {
		panic("moq: ChapterRepositoryMock.DeleteFunc is nil but ChapterRepository.Delete was just called")
	}
	callInfo := struct {
		In1 *entities.Chapter
	}{
		In1: in1,
	}
	lockChapterRepositoryMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockChapterRepositoryMockDelete.Unlock()
	return mock.DeleteFunc(in1)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedChapterRepository.DeleteCalls())
func (mock *ChapterRepositoryMock) DeleteCalls() []struct {
	In1 *entities.Chapter
} {
	var calls []struct {
		In1 *entities.Chapter
	}
	lockChapterRepositoryMockDelete.RLock()
	calls = mock.calls.Delete
	lockChapterRepositoryMockDelete.RUnlock()
	return calls
}

// FindById calls FindByIdFunc.
func (mock *ChapterRepositoryMock) FindById(in1 int) (entities.Chapter, app_error.AppError) {
	if mock.FindByIdFunc == nil {
		panic("moq: ChapterRepositoryMock.FindByIdFunc is nil but ChapterRepository.FindById was just called")
	}
	callInfo := struct {
		In1 int
	}{
		In1: in1,
	}
	lockChapterRepositoryMockFindById.Lock()
	mock.calls.FindById = append(mock.calls.FindById, callInfo)
	lockChapterRepositoryMockFindById.Unlock()
	return mock.FindByIdFunc(in1)
}

// FindByIdCalls gets all the calls that were made to FindById.
// Check the length with:
//     len(mockedChapterRepository.FindByIdCalls())
func (mock *ChapterRepositoryMock) FindByIdCalls() []struct {
	In1 int
} {
	var calls []struct {
		In1 int
	}
	lockChapterRepositoryMockFindById.RLock()
	calls = mock.calls.FindById
	lockChapterRepositoryMockFindById.RUnlock()
	return calls
}

// FindWithinBook calls FindWithinBookFunc.
func (mock *ChapterRepositoryMock) FindWithinBook(chapter_id int, book_id int) (entities.Chapter, app_error.AppError) {
	if mock.FindWithinBookFunc == nil {
		panic("moq: ChapterRepositoryMock.FindWithinBookFunc is nil but ChapterRepository.FindWithinBook was just called")
	}
	callInfo := struct {
		Chapter_id int
		Book_id    int
	}{
		Chapter_id: chapter_id,
		Book_id:    book_id,
	}
	lockChapterRepositoryMockFindWithinBook.Lock()
	mock.calls.FindWithinBook = append(mock.calls.FindWithinBook, callInfo)
	lockChapterRepositoryMockFindWithinBook.Unlock()
	return mock.FindWithinBookFunc(chapter_id, book_id)
}

// FindWithinBookCalls gets all the calls that were made to FindWithinBook.
// Check the length with:
//     len(mockedChapterRepository.FindWithinBookCalls())
func (mock *ChapterRepositoryMock) FindWithinBookCalls() []struct {
	Chapter_id int
	Book_id    int
} {
	var calls []struct {
		Chapter_id int
		Book_id    int
	}
	lockChapterRepositoryMockFindWithinBook.RLock()
	calls = mock.calls.FindWithinBook
	lockChapterRepositoryMockFindWithinBook.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *ChapterRepositoryMock) Insert(in1 *entities.Chapter) app_error.AppError {
	if mock.InsertFunc == nil {
		panic("moq: ChapterRepositoryMock.InsertFunc is nil but ChapterRepository.Insert was just called")
	}
	callInfo := struct {
		In1 *entities.Chapter
	}{
		In1: in1,
	}
	lockChapterRepositoryMockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	lockChapterRepositoryMockInsert.Unlock()
	return mock.InsertFunc(in1)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//     len(mockedChapterRepository.InsertCalls())
func (mock *ChapterRepositoryMock) InsertCalls() []struct {
	In1 *entities.Chapter
} {
	var calls []struct {
		In1 *entities.Chapter
	}
	lockChapterRepositoryMockInsert.RLock()
	calls = mock.calls.Insert
	lockChapterRepositoryMockInsert.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ChapterRepositoryMock) Update(in1 *entities.Chapter) app_error.AppError {
	if mock.UpdateFunc == nil {
		panic("moq: ChapterRepositoryMock.UpdateFunc is nil but ChapterRepository.Update was just called")
	}
	callInfo := struct {
		In1 *entities.Chapter
	}{
		In1: in1,
	}
	lockChapterRepositoryMockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	lockChapterRepositoryMockUpdate.Unlock()
	return mock.UpdateFunc(in1)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedChapterRepository.UpdateCalls())
func (mock *ChapterRepositoryMock) UpdateCalls() []struct {
	In1 *entities.Chapter
} {
	var calls []struct {
		In1 *entities.Chapter
	}
	lockChapterRepositoryMockUpdate.RLock()
	calls = mock.calls.Update
	lockChapterRepositoryMockUpdate.RUnlock()
	return calls
}
